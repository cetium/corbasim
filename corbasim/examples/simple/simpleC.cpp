// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v1.7.9
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:355


#include "simpleC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Array_Impl_T.h"
#include "tao/Basic_Arguments.h"
#include "tao/Object_Argument_T.h"
#include "tao/Var_Size_Argument_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "simpleC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:68

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:855

#if !defined (_SIMPLEEXAMPLE_ST__ARG_TRAITS_)
#define _SIMPLEEXAMPLE_ST__ARG_TRAITS_
  
  template<>
  class Arg_Traits<SimpleExample::St>
    : public
        Var_Size_Arg_Traits_T<
            SimpleExample::St,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:136

#if !defined (_SIMPLEEXAMPLE_TEST__ARG_TRAITS_)
#define _SIMPLEEXAMPLE_TEST__ARG_TRAITS_
  
  template<>
  class  Arg_Traits<SimpleExample::Test>
    : public
        Object_Arg_Traits_T<
            SimpleExample::Test_ptr,
            SimpleExample::Test_var,
            SimpleExample::Test_out,
            TAO::Objref_Traits<SimpleExample::Test>,
            TAO::Any_Insert_Policy_Stream
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:82

SimpleExample::MyUnion::MyUnion (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->_default ();
}

SimpleExample::MyUnion::MyUnion (const ::SimpleExample::MyUnion &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 100:
    {
      this->u_.aa_ = u.u_.aa_;
    }
    break;
    case 101:
    {
      this->u_.bb_ = u.u_.bb_;
    }
    break;
    default:
    break;
  }
}

SimpleExample::MyUnion::~MyUnion (void)
{
  // Finalize.
  this->_reset ();
}

void SimpleExample::MyUnion::_tao_any_destructor (void *_tao_void_pointer)
{
  MyUnion *tmp =
    static_cast<MyUnion *> (_tao_void_pointer);
  delete tmp;
}

SimpleExample::MyUnion &
SimpleExample::MyUnion::operator= (const ::SimpleExample::MyUnion &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;
  
  switch (this->disc_)
  {
    case 100:
    {
      this->u_.aa_ = u.u_.aa_;
    }
    break;
    case 101:
    {
      this->u_.bb_ = u.u_.bb_;
    }
    break;
    default:
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void SimpleExample::MyUnion::_reset (void)
{
  switch (this->disc_)
  {
    
    case 100:
      break;
    case 101:
      break;
    default:
    break;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/union_typecode.cpp:65

static TAO::TypeCode::Case_T<CORBA::Long, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_SimpleExample_MyUnion__0 (100, "aa", &CORBA::_tc_long);
static TAO::TypeCode::Case_T<CORBA::Long, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_SimpleExample_MyUnion__1 (101, "bb", &CORBA::_tc_long);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_SimpleExample_MyUnion[] =
  {
    &_tao_cases_SimpleExample_MyUnion__0,
    &_tao_cases_SimpleExample_MyUnion__1
    
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_SimpleExample_MyUnion (
    "IDL:SimpleExample/MyUnion:1.0",
    "MyUnion",
    &CORBA::_tc_long,
    _tao_cases_SimpleExample_MyUnion,
    2, -1);
  
namespace SimpleExample
{
  ::CORBA::TypeCode_ptr const _tc_MyUnion =
    &_tao_tc_SimpleExample_MyUnion;
}



// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:84



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:510


#ifndef _TAO_TYPECODE_SimpleExample_St__tao_seq_CORBA_Long__GUARD
#define _TAO_TYPECODE_SimpleExample_St__tao_seq_CORBA_Long__GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        SimpleExample_St__tao_seq_CORBA_Long__0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_long,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_SimpleExample_St__tao_seq_CORBA_Long__0 =
        &SimpleExample_St__tao_seq_CORBA_Long__0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_SimpleExample_St__tao_seq_CORBA_Long__GUARD */



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:510


#ifndef _TAO_TYPECODE_SimpleExample_St__tao_seq_CORBA_STRING__GUARD
#define _TAO_TYPECODE_SimpleExample_St__tao_seq_CORBA_STRING__GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        SimpleExample_St__tao_seq_CORBA_STRING__0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_string,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_SimpleExample_St__tao_seq_CORBA_STRING__0 =
        &SimpleExample_St__tao_seq_CORBA_STRING__0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_SimpleExample_St__tao_seq_CORBA_STRING__GUARD */

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SimpleExample_St[] =
      {
        { "l", &TAO::TypeCode::tc_SimpleExample_St__tao_seq_CORBA_Long__0 },
        { "ss", &TAO::TypeCode::tc_SimpleExample_St__tao_seq_CORBA_STRING__0 },
        { "b", &CORBA::_tc_long },
        { "uniii", &SimpleExample::_tc_MyUnion }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SimpleExample_St (
  ::CORBA::tk_struct,
  "IDL:SimpleExample/St:1.0",
  "St",
  _tao_fields_SimpleExample_St,
  4);

namespace SimpleExample
{
  ::CORBA::TypeCode_ptr const _tc_St =
    &_tao_tc_SimpleExample_St;
}



// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:56

void 
SimpleExample::St::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  St *_tao_tmp_pointer =
    static_cast<St *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:56

#if !defined (_SIMPLEEXAMPLE_ST__TAO_SEQ_CORBA_LONG__CS_)
#define _SIMPLEEXAMPLE_ST__TAO_SEQ_CORBA_LONG__CS_

SimpleExample::St::_tao_seq_CORBA_Long_::_tao_seq_CORBA_Long_ (void)
{}

SimpleExample::St::_tao_seq_CORBA_Long_::_tao_seq_CORBA_Long_ (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      >
    (max)
{}

SimpleExample::St::_tao_seq_CORBA_Long_::_tao_seq_CORBA_Long_ (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      >
    (max, length, buffer, release)
{}

SimpleExample::St::_tao_seq_CORBA_Long_::_tao_seq_CORBA_Long_ (
    const _tao_seq_CORBA_Long_ &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      >
    (seq)
{}

SimpleExample::St::_tao_seq_CORBA_Long_::~_tao_seq_CORBA_Long_ (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:56

#if !defined (_SIMPLEEXAMPLE_ST__TAO_SEQ_CORBA_STRING__CS_)
#define _SIMPLEEXAMPLE_ST__TAO_SEQ_CORBA_STRING__CS_

SimpleExample::St::_tao_seq_CORBA_STRING_::_tao_seq_CORBA_STRING_ (void)
{}

SimpleExample::St::_tao_seq_CORBA_STRING_::_tao_seq_CORBA_STRING_ (
    ::CORBA::ULong max)
  : ::TAO::unbounded_basic_string_sequence<char>
    (max)
{}

SimpleExample::St::_tao_seq_CORBA_STRING_::_tao_seq_CORBA_STRING_ (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Char * * buffer,
    ::CORBA::Boolean release)
  : ::TAO::unbounded_basic_string_sequence<char>
    (max, length, buffer, release)
{}

SimpleExample::St::_tao_seq_CORBA_STRING_::_tao_seq_CORBA_STRING_ (
    const _tao_seq_CORBA_STRING_ &seq)
  : ::TAO::unbounded_basic_string_sequence<char>
    (seq)
{}

SimpleExample::St::_tao_seq_CORBA_STRING_::~_tao_seq_CORBA_STRING_ (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:51

// Traits specializations for SimpleExample::Test.

SimpleExample::Test_ptr
TAO::Objref_Traits<SimpleExample::Test>::duplicate (
    SimpleExample::Test_ptr p)
{
  return SimpleExample::Test::_duplicate (p);
}

void
TAO::Objref_Traits<SimpleExample::Test>::release (
    SimpleExample::Test_ptr p)
{
  ::CORBA::release (p);
}

SimpleExample::Test_ptr
TAO::Objref_Traits<SimpleExample::Test>::nil (void)
{
  return SimpleExample::Test::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<SimpleExample::Test>::marshal (
    const SimpleExample::Test_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*SimpleExample__TAO_Test_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj) = 0;

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:68

void
SimpleExample::Test::operation1 (
  ::CORBA::Long a,
  ::CORBA::Long b,
  const ::SimpleExample::St & c)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Test_Proxy_Broker_ == 0)
    {
      SimpleExample_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_a (a);
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_b (b);
  TAO::Arg_Traits< ::SimpleExample::St>::in_arg_val _tao_c (c);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_a,
      &_tao_b,
      &_tao_c
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "operation1",
      10,
      this->the_TAO_Test_Proxy_Broker_,
      TAO::TAO_ONEWAY_INVOCATION
    );
  
  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:100

SimpleExample::Test::a_t_slice *
SimpleExample::Test::a_t_dup (const SimpleExample::Test::a_t_slice *_tao_src_array)
{
  SimpleExample::Test::a_t_slice *_tao_dup_array =
    SimpleExample::Test::a_t_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <SimpleExample::Test::a_t_slice *> (0);
    }
  
  SimpleExample::Test::a_t_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

SimpleExample::Test::a_t_slice *
SimpleExample::Test::a_t_alloc (void)
{
  SimpleExample::Test::a_t_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Long[100], 0);
  return retval;
}

void
SimpleExample::Test::a_t_free (
    SimpleExample::Test::a_t_slice *_tao_slice
  )
{
  delete [] _tao_slice;
}

void 
SimpleExample::Test::a_t_copy (
    SimpleExample::Test::a_t_slice * _tao_to,
    const SimpleExample::Test::a_t_slice *_tao_from
  )
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 100; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:347


#ifndef _TAO_TYPECODE_SimpleExample_Test_a_t_GUARD
#define _TAO_TYPECODE_SimpleExample_Test_a_t_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        SimpleExample_Test_a_t_100 (
          ::CORBA::tk_array,
          &CORBA::_tc_long,
          100U);
        
      ::CORBA::TypeCode_ptr const tc_SimpleExample_Test_a_t =
        &SimpleExample_Test_a_t_100;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_SimpleExample_Test_a_t_GUARD */
static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_SimpleExample_Test_a_t (
    ::CORBA::tk_alias,
    "IDL:SimpleExample/Test/a_t:1.0",
    "a_t",
    &TAO::TypeCode::tc_SimpleExample_Test_a_t);
  
::CORBA::TypeCode_ptr const SimpleExample::Test::_tc_a_t =
  &_tao_tc_SimpleExample_Test_a_t;

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:68

void
SimpleExample::Test::operation4 (
  ::SimpleExample::Test_ptr a)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Test_Proxy_Broker_ == 0)
    {
      SimpleExample_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::SimpleExample::Test>::in_arg_val _tao_a (a);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_a
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "operation4",
      10,
      this->the_TAO_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
}

SimpleExample::Test::Test (void)
 : the_TAO_Test_Proxy_Broker_ (0)
{
  this->SimpleExample_Test_setup_collocation ();
}

void
SimpleExample::Test::SimpleExample_Test_setup_collocation ()
{
  if (::SimpleExample__TAO_Test_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Test_Proxy_Broker_ =
        ::SimpleExample__TAO_Test_Proxy_Broker_Factory_function_pointer (this);
    }
}

SimpleExample::Test::~Test (void)
{}

void 
SimpleExample::Test::_tao_any_destructor (void *_tao_void_pointer)
{
  Test *_tao_tmp_pointer =
    static_cast<Test *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

SimpleExample::Test_ptr
SimpleExample::Test::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Test>::narrow (
        _tao_objref,
        "IDL:SimpleExample/Test:1.0",
        SimpleExample__TAO_Test_Proxy_Broker_Factory_function_pointer
      );
}

SimpleExample::Test_ptr
SimpleExample::Test::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<Test>::unchecked_narrow (
        _tao_objref,
        "IDL:SimpleExample/Test:1.0",
        SimpleExample__TAO_Test_Proxy_Broker_Factory_function_pointer
      );
}

SimpleExample::Test_ptr
SimpleExample::Test::_duplicate (Test_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
SimpleExample::Test::_tao_release (Test_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
SimpleExample::Test::_is_a (const char *value)
{
  if (
      !ACE_OS::strcmp (
          value,
          "IDL:SimpleExample/Test:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* SimpleExample::Test::_interface_repository_id (void) const
{
  return "IDL:SimpleExample/Test:1.0";
}

::CORBA::Boolean
SimpleExample::Test::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/objref_typecode.cpp:76

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_SimpleExample_Test (
    ::CORBA::tk_objref,
    "IDL:SimpleExample/Test:1.0",
    "Test");
  
namespace SimpleExample
{
  ::CORBA::TypeCode_ptr const _tc_Test =
    &_tao_tc_SimpleExample_Test;
}



// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SimpleExample_Hijo[] =
      {
        { "b", &CORBA::_tc_long },
        { "l", &CORBA::_tc_boolean },
        { "s", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SimpleExample_Hijo (
  ::CORBA::tk_struct,
  "IDL:SimpleExample/Hijo:1.0",
  "Hijo",
  _tao_fields_SimpleExample_Hijo,
  3);

namespace SimpleExample
{
  ::CORBA::TypeCode_ptr const _tc_Hijo =
    &_tao_tc_SimpleExample_Hijo;
}



// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:56

void 
SimpleExample::Hijo::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Hijo *_tao_tmp_pointer =
    static_cast<Hijo *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SimpleExample_Padre[] =
      {
        { "h", &SimpleExample::_tc_Hijo }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SimpleExample_Padre (
  ::CORBA::tk_struct,
  "IDL:SimpleExample/Padre:1.0",
  "Padre",
  _tao_fields_SimpleExample_Padre,
  1);

namespace SimpleExample
{
  ::CORBA::TypeCode_ptr const _tc_Padre =
    &_tao_tc_SimpleExample_Padre;
}



// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:56

void 
SimpleExample::Padre::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Padre *_tao_tmp_pointer =
    static_cast<Padre *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:100

SimpleExample::Padres_slice *
SimpleExample::Padres_dup (const SimpleExample::Padres_slice *_tao_src_array)
{
  SimpleExample::Padres_slice *_tao_dup_array =
    SimpleExample::Padres_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <SimpleExample::Padres_slice *> (0);
    }
  
  SimpleExample::Padres_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

SimpleExample::Padres_slice *
SimpleExample::Padres_alloc (void)
{
  SimpleExample::Padres_slice *retval = 0;
  ACE_NEW_RETURN (retval, SimpleExample::Padre[10], 0);
  return retval;
}

void
SimpleExample::Padres_free (
    SimpleExample::Padres_slice *_tao_slice
  )
{
  delete [] _tao_slice;
}

void 
SimpleExample::Padres_copy (
    SimpleExample::Padres_slice * _tao_to,
    const SimpleExample::Padres_slice *_tao_from
  )
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:347


#ifndef _TAO_TYPECODE_SimpleExample_Padres_GUARD
#define _TAO_TYPECODE_SimpleExample_Padres_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        SimpleExample_Padres_10 (
          ::CORBA::tk_array,
          &SimpleExample::_tc_Padre,
          10U);
        
      ::CORBA::TypeCode_ptr const tc_SimpleExample_Padres =
        &SimpleExample_Padres_10;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_SimpleExample_Padres_GUARD */
static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_SimpleExample_Padres (
    ::CORBA::tk_alias,
    "IDL:SimpleExample/Padres:1.0",
    "Padres",
    &TAO::TypeCode::tc_SimpleExample_Padres);
  
namespace SimpleExample
{
  ::CORBA::TypeCode_ptr const _tc_Padres =
    &_tao_tc_SimpleExample_Padres;
}



// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:84



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:347

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_SimpleExample_Abuelo[] =
      {
        { "p", &SimpleExample::_tc_Padres },
        { "tt", &SimpleExample::_tc_Test }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_SimpleExample_Abuelo (
  ::CORBA::tk_struct,
  "IDL:SimpleExample/Abuelo:1.0",
  "Abuelo",
  _tao_fields_SimpleExample_Abuelo,
  2);

namespace SimpleExample
{
  ::CORBA::TypeCode_ptr const _tc_Abuelo =
    &_tao_tc_SimpleExample_Abuelo;
}



// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:56

void 
SimpleExample::Abuelo::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Abuelo *_tao_tmp_pointer =
    static_cast<Abuelo *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// be/be_visitor_union/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SimpleExample::MyUnion &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<SimpleExample::MyUnion *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<SimpleExample::MyUnion>::insert_copy (
        _tao_any,
        SimpleExample::MyUnion::_tao_any_destructor,
        SimpleExample::_tc_MyUnion,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SimpleExample::MyUnion *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<SimpleExample::MyUnion>::insert (
      _tao_any,
      SimpleExample::MyUnion::_tao_any_destructor,
      SimpleExample::_tc_MyUnion,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SimpleExample::MyUnion *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const SimpleExample::MyUnion *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SimpleExample::MyUnion *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SimpleExample::MyUnion>::extract (
        _tao_any,
        SimpleExample::MyUnion::_tao_any_destructor,
        SimpleExample::_tc_MyUnion,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SimpleExample::St &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<SimpleExample::St *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<SimpleExample::St>::insert_copy (
        _tao_any,
        SimpleExample::St::_tao_any_destructor,
        SimpleExample::_tc_St,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SimpleExample::St *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<SimpleExample::St>::insert (
      _tao_any,
      SimpleExample::St::_tao_any_destructor,
      SimpleExample::_tc_St,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SimpleExample::St *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const SimpleExample::St *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SimpleExample::St *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SimpleExample::St>::extract (
        _tao_any,
        SimpleExample::St::_tao_any_destructor,
        SimpleExample::_tc_St,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:49
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<SimpleExample::Test>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL



#if defined (ACE_ANY_OPS_USE_NAMESPACE)

namespace SimpleExample
{
  
  
  /// Copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Test_ptr _tao_elem)
  {
    Test_ptr _tao_objptr =
      Test::_duplicate (_tao_elem);
    _tao_any <<= &_tao_objptr;
  }
  
  /// Non-copying insertion.
  void
  operator<<= (
      ::CORBA::Any &_tao_any,
      Test_ptr *_tao_elem)
  {
    TAO::Any_Impl_T<Test>::insert (
        _tao_any,
        Test::_tao_any_destructor,
        _tc_Test,
        *_tao_elem)
  }
  
  ::CORBA::Boolean
  operator>>= (
      const ::CORBA::Any &_tao_any,
      Test_ptr &_tao_elem)
  {
    return
      TAO::Any_Impl_T<Test>::extract (
          _tao_any,
          Test::_tao_any_destructor,
          _tc_Test,
          _tao_elem)
  }
}

#else

TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SimpleExample::Test_ptr _tao_elem)
{
  SimpleExample::Test_ptr _tao_objptr =
    SimpleExample::Test::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    SimpleExample::Test_ptr *_tao_elem)
{
  TAO::Any_Impl_T<SimpleExample::Test>::insert (
      _tao_any,
      SimpleExample::Test::_tao_any_destructor,
      SimpleExample::_tc_Test,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    SimpleExample::Test_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<SimpleExample::Test>::extract (
        _tao_any,
        SimpleExample::Test::_tao_any_destructor,
        SimpleExample::_tc_Test,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



#endif

// TAO_IDL - Generated from 
// be/be_visitor_array/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    const SimpleExample::Test::a_t_forany &_tao_elem
  )
{
  TAO::Any_Array_Impl_T<
      SimpleExample::Test::a_t_slice,
      SimpleExample::Test::a_t_forany
    >::insert (
        _tao_any,
        SimpleExample::Test::a_t_forany::_tao_any_destructor,
        SimpleExample::Test::_tc_a_t,
        _tao_elem.nocopy ()
          ? _tao_elem.ptr ()
          : SimpleExample::Test::a_t_dup (_tao_elem.in ())
      );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SimpleExample::Test::a_t_forany &_tao_elem
  )
{
  return
    TAO::Any_Array_Impl_T<
        SimpleExample::Test::a_t_slice,
        SimpleExample::Test::a_t_forany
      >::extract (
          _tao_any,
          SimpleExample::Test::a_t_forany::_tao_any_destructor,
          SimpleExample::Test::_tc_a_t,
          _tao_elem.out ()
        );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SimpleExample::Hijo &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<SimpleExample::Hijo *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<SimpleExample::Hijo>::insert_copy (
        _tao_any,
        SimpleExample::Hijo::_tao_any_destructor,
        SimpleExample::_tc_Hijo,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SimpleExample::Hijo *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<SimpleExample::Hijo>::insert (
      _tao_any,
      SimpleExample::Hijo::_tao_any_destructor,
      SimpleExample::_tc_Hijo,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SimpleExample::Hijo *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const SimpleExample::Hijo *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SimpleExample::Hijo *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SimpleExample::Hijo>::extract (
        _tao_any,
        SimpleExample::Hijo::_tao_any_destructor,
        SimpleExample::_tc_Hijo,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SimpleExample::Padre &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<SimpleExample::Padre *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<SimpleExample::Padre>::insert_copy (
        _tao_any,
        SimpleExample::Padre::_tao_any_destructor,
        SimpleExample::_tc_Padre,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SimpleExample::Padre *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<SimpleExample::Padre>::insert (
      _tao_any,
      SimpleExample::Padre::_tao_any_destructor,
      SimpleExample::_tc_Padre,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SimpleExample::Padre *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const SimpleExample::Padre *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SimpleExample::Padre *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SimpleExample::Padre>::extract (
        _tao_any,
        SimpleExample::Padre::_tao_any_destructor,
        SimpleExample::_tc_Padre,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// be/be_visitor_array/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    const SimpleExample::Padres_forany &_tao_elem
  )
{
  TAO::Any_Array_Impl_T<
      SimpleExample::Padres_slice,
      SimpleExample::Padres_forany
    >::insert (
        _tao_any,
        SimpleExample::Padres_forany::_tao_any_destructor,
        SimpleExample::_tc_Padres,
        _tao_elem.nocopy ()
          ? _tao_elem.ptr ()
          : SimpleExample::Padres_dup (_tao_elem.in ())
      );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SimpleExample::Padres_forany &_tao_elem
  )
{
  return
    TAO::Any_Array_Impl_T<
        SimpleExample::Padres_slice,
        SimpleExample::Padres_forany
      >::extract (
          _tao_any,
          SimpleExample::Padres_forany::_tao_any_destructor,
          SimpleExample::_tc_Padres,
          _tao_elem.out ()
        );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:45


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const SimpleExample::Abuelo &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<SimpleExample::Abuelo *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<SimpleExample::Abuelo>::insert_copy (
        _tao_any,
        SimpleExample::Abuelo::_tao_any_destructor,
        SimpleExample::_tc_Abuelo,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    SimpleExample::Abuelo *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<SimpleExample::Abuelo>::insert (
      _tao_any,
      SimpleExample::Abuelo::_tao_any_destructor,
      SimpleExample::_tc_Abuelo,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    SimpleExample::Abuelo *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const SimpleExample::Abuelo *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const SimpleExample::Abuelo *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<SimpleExample::Abuelo>::extract (
        _tao_any,
        SimpleExample::Abuelo::_tao_any_destructor,
        SimpleExample::_tc_Abuelo,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:58


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SimpleExample::MyUnion &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;
  
  switch (_tao_union._d ())
  {
    case 100:
      {
        result = strm << _tao_union.aa ();
      }
      break;
    case 101:
      {
        result = strm << _tao_union.bb ();
      }
      break;
    default:
      break;
  }
  
  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SimpleExample::MyUnion &_tao_union
  )
{
  CORBA::Long _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;
  
  switch (_tao_discriminant)
  {
    case 100:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.aa (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 101:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.bb (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatability, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }
  
  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:94
#if !defined _TAO_CDR_OP_SimpleExample_St__tao_seq_CORBA_Long__CPP_
#define _TAO_CDR_OP_SimpleExample_St__tao_seq_CORBA_Long__CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SimpleExample::St::_tao_seq_CORBA_Long_ &_tao_sequence
  )
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SimpleExample::St::_tao_seq_CORBA_Long_ &_tao_sequence
  )
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_SimpleExample_St__tao_seq_CORBA_Long__CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:94
#if !defined _TAO_CDR_OP_SimpleExample_St__tao_seq_CORBA_STRING__CPP_
#define _TAO_CDR_OP_SimpleExample_St__tao_seq_CORBA_STRING__CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SimpleExample::St::_tao_seq_CORBA_STRING_ &_tao_sequence
  )
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SimpleExample::St::_tao_seq_CORBA_STRING_ &_tao_sequence
  )
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_SimpleExample_St__tao_seq_CORBA_STRING__CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SimpleExample::St &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.l) &&
    (strm << _tao_aggregate.ss) &&
    (strm << _tao_aggregate.b) &&
    (strm << _tao_aggregate.uniii);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SimpleExample::St &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.l) &&
    (strm >> _tao_aggregate.ss) &&
    (strm >> _tao_aggregate.b) &&
    (strm >> _tao_aggregate.uniii);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:171


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SimpleExample::Test::a_t_forany &_tao_array
  )
{
  return
    strm.write_long_array (
        reinterpret_cast <const ACE_CDR::Long *> (_tao_array.in ()),
        100
      );
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SimpleExample::Test::a_t_forany &_tao_array
  )
{
  return
    strm.read_long_array (
        reinterpret_cast <ACE_CDR::Long *> (_tao_array.out ()),
        100
      );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:54

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SimpleExample::Test_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SimpleExample::Test_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;
  
  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::SimpleExample::Test RHS_SCOPED_NAME;
  
  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        SimpleExample__TAO_Test_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SimpleExample::Hijo &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.b) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.l)) &&
    (strm << _tao_aggregate.s.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SimpleExample::Hijo &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.b) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.l)) &&
    (strm >> _tao_aggregate.s.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SimpleExample::Padre &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.h);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SimpleExample::Padre &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.h);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:171


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SimpleExample::Padres_forany &_tao_array
  )
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 10 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm << _tao_array [i0]);
    }
  
  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SimpleExample::Padres_forany &_tao_array
  )
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 10 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm >> _tao_array [i0]);
    }
  
  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const SimpleExample::Abuelo &_tao_aggregate
  )
{
  SimpleExample::Padres_forany _tao_aggregate_p
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((SimpleExample::Padres_slice*) (
      #else
      (const_cast<
          SimpleExample::Padres_slice*> (
      #endif
          _tao_aggregate.p
        )
    );
  return
    (strm << _tao_aggregate_p) &&
    ::CORBA::Object::marshal (
        _tao_aggregate.tt.in (),
        strm
      );
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    SimpleExample::Abuelo &_tao_aggregate
  )
{
  SimpleExample::Padres_forany _tao_aggregate_p
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((SimpleExample::Padres_slice*) (
      #else
      (const_cast<
          SimpleExample::Padres_slice*> (
      #endif
          _tao_aggregate.p
        )
    );
  return
    (strm >> _tao_aggregate_p) &&
    (strm >> _tao_aggregate.tt.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



